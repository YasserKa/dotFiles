#!/usr/bin/env bash
# Get Paper DOI
#
# $1: URL to paper
# returns DOI

function main() {
	SOURCE="$1"
	TMP_FILE2="/tmp/zotero_return_value"
	rm -f "$TMP_FILE2"
	trap 'rm -f $TMP_FILE2' RETURN
	HTML_PATH="$(mktemp -t "tmp_XXX.html")"
	readonly HTML_PATH
	get_page_content "$SOURCE" "$HTML_PATH"

	# shellcheck disable=2016
	SCRIPT='
  (async function () {
    let uri = "'"$SOURCE"'"
    var cookieSandbox = uri
      ? new Zotero.CookieSandbox(null, uri, "", null)
      : null;

    var parser = new DOMParser();
    var data = await Zotero.File.getContentsAsync("'"$HTML_PATH"'");
    var doc = parser.parseFromString(`<html>${data}</html>`, "text/html");
    doc = Zotero.HTTP.wrapDocument(doc, uri);

    let translate = new Zotero.Translate.Web();
    translate.setDocument(doc);
    cookieSandbox && translate.setCookieSandbox(cookieSandbox);

    let translators = await translate.getTranslators();

    if (translators.length == 0) {
      result = "Error: No translators found";
    } else {
      translate.setTranslator(translators[0].translatorID);

      // Set handler to capture items WITHOUT saving them
      translate.setHandler("itemDone", function(obj, item) {
        if (item.DOI) {
          result = item.DOI;
        } else {
          result = "No DOI found";
        }
      });

      // Translate without saving to library
      await translate.translate({
        libraryID: false  // Dont save to any library
      });
    }

	  await Zotero.File.putContentsAsync("'"$TMP_FILE2"'", result);
  })();
  '

	nc 127.0.0.1 8080 < <(echo "$SCRIPT")

	until [[ -f "$TMP_FILE2" ]]; do
		sleep 0.1
	done

	cat "$TMP_FILE2"
}

main "$@"
