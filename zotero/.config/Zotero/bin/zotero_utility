#!/usr/bin/env bash
# Zotero utility:
# - Import to zotero from various sources to a collection
# - Get a paper's DOI or title
# - Search for papers
# - Focus entry in zotero
#
# Arguments:
#   zotero_utility [import|get_metadata|search|focus_entry] args
#
#   import:
#   --collection_name <collection_name>: Colletion name (optional)
#   or
#   --recent: Import to the collection that was imported before (optional)
#   or
#   --add_org_entry: Adds entry to org mode
#   <SOURCE>: URL or path to paper
#
#   get_metadata:
#   $1: [DOI|title]
#   $2: SOURCE: URL or path to paper
#
#   focus_entry:
#   $1: File path
#
# Dependencies: zotero, netcat

get_collection_id_from_name() {
	local -r COLLECTION_NAME="$1"

	script='
  (async function () {
let collections = Zotero.Collections.getLoaded()
let collectionId = 0
for (let collection of collections) {
  if (collection.name == "'"$COLLECTION_NAME"'") {
    collectionId = collection.id;
    break;
  }
}

result=collectionId.toString()
'
	eval_script_return_value "$script"
}

pick_collection_id() {
	script='
  (async function () {
  let libraries = await Zotero.Libraries.getAll()

  let collections_str = ""

  function get_collections(collections, name) {

  for (let collection of collections) {
    if (collection.hasChildCollections()) {
      collections_str += collection.key + "\t" + name + " >> " + collection.name + "\n"
      get_collections(collection.getChildCollections(), name + " >> " + collection.name)
    } else {
    collections_str += collection.key + "\t" + name + " >> " + collection.name +"\n"
  }
}
return collections_str
}

let collections = await Zotero.Collections.getLoaded()

for (let library of libraries) {
  let collections = await Zotero.Collections.getByLibrary(library.id)
  collections_str += get_collections(collections, library.name)
}

result = collections_str
'

	result="$(eval_script_return_value "$script")"

	result="$(command cat <(fre --store_name "$FRE_NAME" --sorted | grep -Fx -f <(echo "$result")) <(echo "$result" | grep -Fvx -f <(fre --store_name "$FRE_NAME" --sorted)))"
	result="${result//>>/\\033[36m>>\\033[0m}"

	TMP_FILE="$(mktemp -t "tmp_XXX")"
	readonly TMP_FILE

	trap 'rm $TMP_FILE' RETURN

	IFS='' read -r -d '' cmd <<EOF
  printf "$result" |  fzf --ansi --with-nth '{2..}' --preview-window hidden >| '${TMP_FILE}'
EOF

	eval_interactive_cmd --floating "$cmd"

	[[ -s "$TMP_FILE" ]] || exit 0

	fre --store_name "$FRE_NAME" --add "$(cat "$TMP_FILE")"
	collection_key="$(<"$TMP_FILE" cut -d $'\t' -f 1)"

	script='
(async function () {
let libraryId = await Zotero.Libraries.getAll()[0].id

let collectionId = await Zotero.Collections.getByLibraryAndKey(libraryId, "'"$collection_key"'").id

result=collectionId.toString()
'
	eval_script_return_value "$script"
}

import_source() {
	local TMP_FILE_RECENT_COLLECTION_ID="$XDG_DATA_HOME/zotero_recent_collection_id"
	local COLLECTION_NAME RECENT SOURCE ADD_ORG_ENTRY

	while :; do
		case $1 in
			--collection_name)
				COLLECTION_NAME="$2"
				shift
				;;
			--recent)
				RECENT="true"
				;;
			--add_org_entry)
				ADD_ORG_ENTRY="true"
				;;
			*)
				# Could be changed to remove em-dashes
				SOURCE="$1"
				break
				;;
		esac
		shift
	done

	declare -r FRE_NAME="zotero_collection"

	if [[ "$RECENT" == "true" ]]; then
		# Use most recent file
		source "$TMP_FILE_RECENT_COLLECTION_ID"
	elif [[ -n "$COLLECTION_NAME" ]]; then
		declare -r COLLECTION_ID="$(get_collection_id_from_name "$COLLECTION_NAME")"
	else # Pick interactively
		declare -r COLLECTION_ID="$(pick_collection_id)"
	fi
	# Don't track reading collection
	[[ -n "$COLLECTION_ID" && "$COLLECTION_NAME" != "To_Read" ]] && declare -p COLLECTION_ID >|"$TMP_FILE_RECENT_COLLECTION_ID"

	[[ -z "$COLLECTION_ID" ]] && exit 0

	if [[ -f "$SOURCE" ]]; then
		# Attach document

		# If filename contains an em-dash replace it, because JS doesn't like em-dashes
		if [[ "$(basename "$SOURCE")" =~ [—–] ]]; then
			OLD_SOURCE="$SOURCE"
			SOURCE="/tmp/$(basename "$OLD_SOURCE" | sed 's/[—–]/-/g')"
			cp -- "$OLD_SOURCE" "$SOURCE"
		fi

		# Convert to UTF-8 escape sequence (percent-encoding)
		SOURCE=$(python3 -c "import urllib.parse; print(urllib.parse.quote(\"$SOURCE\"))")
		import_script='
  (async function () {
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForCondition(conditionFn, timeoutMs, pollIntervalMs = 100) {
  const startTime = Date.now();

  while (true) {
    if (conditionFn()) { break; }

    if (Date.now() - startTime > timeoutMs) { break; }

    await sleep(pollIntervalMs);
  }
}
  function getZoteroPane() {
		var windows = Zotero.getMainWindows();
		for (let win of windows) {
			if (win.ZoteroPane) return win.ZoteroPane
		  }
	  }
    await getZoteroPane().collectionsView.selectCollection('"$COLLECTION_ID"')

    let path = decodeURIComponent("'$SOURCE'");
    items = await getZoteroPane().addAttachmentFromDialog(false, 0,[path]);
		await waitForCondition(() => items[0].parentID, 10000);
    result = await Zotero.BetterBibTeX.KeyManager.get(items[0].parentID).citationKey
  '
	elif curl --head "$SOURCE" >/dev/null; then

		HTML_PATH="$(mktemp -t "tmp_XXX")"
		readonly HTML_PATH

		trap 'rm -f $HTML_PATH' RETURN
		# Extract web page source code
		get_page_content "$SOURCE" "$HTML_PATH"

		# shellcheck disable=2016
		import_script='
  (async function () {
  var { library, collection, editable } = Zotero.Server.Connector.getSaveTarget();
  var libraryID = library.libraryID;
  let uri = "'"$SOURCE"'"

var cookieSandbox = uri
? new Zotero.CookieSandbox(null, uri, "", null)
: null;

var parser = new DOMParser();
var data = await Zotero.File.getContentsAsync("'"$HTML_PATH"'");

var doc = parser.parseFromString(`<html>${data}</html>`, "text/html");
doc = Zotero.HTTP.wrapDocument(doc, uri);

let translate = (this._translate = new Zotero.Translate.Web());
translate.setDocument(doc);
cookieSandbox && translate.setCookieSandbox(cookieSandbox);

translators = await translate.getTranslators();
if (translators.length == 0) {
    result = "Error: Entry not added"
} else {
translate.setTranslator(translators[0].translatorID);

let items = await translate.translate({
libraryID,
collections: ['"$COLLECTION_ID"'],
});

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForCondition(conditionFn, timeoutMs, pollIntervalMs = 100) {
  const startTime = Date.now();

  while (true) {
    if (conditionFn()) { break; }

    if (Date.now() - startTime > timeoutMs) { break; }

    await sleep(pollIntervalMs);
  }
}

		await waitForCondition(() => items[0], 10000);
    result = await Zotero.BetterBibTeX.KeyManager.get(items[0].getID()).citationKey
}
'
	else
		notify-send "Couldn't import to zotero: $SOURCE"
		exit 1
	fi
	results="$(eval_script_return_value "$import_script")"
	if grep "Error:" <(echo "$results"); then
		exit 1
	else
		if [[ "$ADD_ORG_ENTRY" == "true" ]]; then
			emacsclient --socket-name="$EMACS_ORG_SOCKET" --no-wait "org-protocol://capture?template=p&title=Read [cite:@${results}]"
		fi
		# echo "$results"
		dunstify "Entry Added"
	fi
}

get_metadata() {

	if [[ "$1" != "DOI" && "$1" != "title" ]]; then
		dunstify "Error: first argument must be DOI or title."
		exit 1
	fi

	METADATA="$1"
	SOURCE="$2"

	if [[ -f "$SOURCE" ]]; then
		# Attach document

		# If filename contains an em-dash replace it, because JS doesn't like em-dashes
		if [[ "$(basename "$SOURCE")" =~ [—–] ]]; then
			OLD_SOURCE="$SOURCE"
			SOURCE="/tmp/$(basename "$OLD_SOURCE" | sed 's/[—–]/-/g')"
			cp -- "$OLD_SOURCE" "$SOURCE"
		fi

		SOURCE=$(python3 -c 'import urllib.parse; print(urllib.parse.quote("'"$SOURCE"'"))')
		SCRIPT='
(async function () {
    let path = decodeURIComponent("'$SOURCE'");

  try {
    // Create a linked file attachment (not stored in library)
    let attachment = await Zotero.Attachments.linkFromFile({
      file: path
    });

    // Use autoRecognizeItems to retrieve metadata
    // This is what "Retrieve Metadata for PDF" does internally
    await Zotero.RecognizeDocument.autoRecognizeItems([attachment]);

    // Get the DOI from the parent item that was created
    let metadata = null;
    if (attachment.parentID) {
      let parentItem = await Zotero.Items.getAsync(attachment.parentID);
      if (parentItem) {
        metadata = parentItem.getField("'"$METADATA"'");
        // Clean up - delete both parent and attachment
        await parentItem.eraseTx();
      }
    }
     result = metadata

    // Clean up the attachment if no parent was created
    if (!attachment.parentID) {
      await attachment.eraseTx();
    }

  } catch (error) {
    return "Error: " + error.message;
  }
  '
	elif curl --head "$SOURCE" >/dev/null; then

		HTML_PATH="$(mktemp -t "tmp_XXX.html")"
		readonly HTML_PATH

		trap 'rm -f $HTML_PATH' RETURN
		get_page_content "$SOURCE" "$HTML_PATH"

		# shellcheck disable=2016
		SCRIPT='
  (async function () {
    let url = "'"$SOURCE"'"
    var cookieSandbox = url
      ? new Zotero.CookieSandbox(null, url, "", null)
      : null;

    var parser = new DOMParser();
    var data = await Zotero.File.getContentsAsync("'"$HTML_PATH"'");
    var doc = parser.parseFromString(`<html>${data}</html>`, "text/html");
    doc = Zotero.HTTP.wrapDocument(doc, url);

    let translate = new Zotero.Translate.Web();
    translate.setDocument(doc);
    cookieSandbox && translate.setCookieSandbox(cookieSandbox);

    let translators = await translate.getTranslators();

    if (translators.length == 0) {
      result = "Error: No translators found";
    } else {
      translate.setTranslator(translators[0].translatorID);

      // Set handler to capture items WITHOUT saving them
      translate.setHandler("itemDone", function(obj, item) {
        if (item.'"$METADATA"') {
          result = item.'"$METADATA"';
        } else {
          result = "No '"$METADATA"' found";
        }
      });

      // Translate without saving to library
      await translate.translate({
        libraryID: false  // Dont save to any library
      });
    }
  '
	fi
	eval_script_return_value "$SCRIPT"
}

search_entries() {
	script='
  (async function () {

  let libraries = await Zotero.Libraries.getAll()

  let collections_str = ""
  let items_str = ""
  let storage_path = Zotero.getStorageDirectory().path

  function get_collections(collections, name) {

  for (let collection of collections) {
    if (collection.hasChildCollections()) {
      collections_str += collection.key + "\t" + name + " > " + collection.name
      get_collections(collection.getChildCollections(), name + " > " + collection.name)
    } else {
    collections_str += collection.key + "\t" + name + " > " + collection.name
  }

  if (collection.hasChildItems()) {

    collection_path = name + " > " + collection.name
    collection.getChildItems().forEach(function (item) {
    let item_json = item.toJSON();
    let file_path = "null"
    let url = "null"
    let date = ""
    let creators = ""
    //file_path = Zotero.Attachments.getStorageDirectory(item).path
    if (item._bestAttachmentState != null) {
      if (item._bestAttachmentState.exists && item._bestAttachmentState.type === "pdf") {
        file_path = storage_path + "/" + item._bestAttachmentState.key
      }
    } else if (item._attachments !=null) {
    if (item._attachments.rows.length > 0) {
    for (let row of item._attachments.rows) {
      file_path = Zotero.Attachments.getStorageDirectoryByID(row.itemID).path
    }
  }
}
    if ("url" in item_json) {
      url = item_json.url
    }

    if ("date" in item_json) {
      date = item_json.date
    }

    if (item_json.creators.length > 0) {
      item_json.creators.forEach(function(creator) {
      creators += creator.firstName + " " + creator.lastName + ", ";
      } );
      creators = creators.substring(0, creators.length -2);
    }

    items_str += item._id + "\t" + item_json.key + "\t" + url + "\t" + file_path + "\t" + collection_path + "\t" + item_json.itemType + "\t" + date + "\t" + creators + "\n" + item_json.title + "\n"
  });
}
}
return items_str
}

let collections = await Zotero.Collections.getLoaded()

for (let library of libraries) {
  let collections = await Zotero.Collections.getByLibrary(library.id)
  collections_str += get_collections(collections, library.name)
}

let result = collections_str
'

	result="$(eval_script_return_value "$script")"
	FRE_NAME="zotero_items"

	frecency_result="$(fre --store_name "zotero_items" --sorted)"

	result="$(awk -F$'\t' '
NR==FNR { order[NR] = $1; next }
{
    key = $1;
    val = $1 "\t" $2 "\t" $3 "\t" $4 "\t\033[36m" $5 "\033[0m\t\033[1;38m" $6 "\033[0m\t\033[37m" $7 "\t" $8 "\033[0m" ;
    getline;
    val = val ORS "\033[1;32m" $0 "\033[0m";
    data[key] = val;
    keys[++count] = key;
}
END {
    # Print keys that exist in `a` first, in order

    for (k in order) {
        i=order[k];
        if (i in data) print data[i];
    }
    # Print remaining keys in their original order
    not_found = 1
    for (i = 1; i <= count; i++) {
        not_found = 1
        for (k in order) {
            if (order[k] == keys[i]) {
                not_found = 0
                break;
            }
        }
        if (not_found) {
            print data[keys[i]]
        }
    }
  }' <(echo "$frecency_result") <(echo "$result"))"

	awk 'NR==1 {print; next} NR%2==0 {printf "%s\0", $0; next} {print}' < <(echo "$result") >|/tmp/result_null

	# Focus collection and item in Zotero JS
	focus_zotero_item='(async function() {
    function getZoteroPane() {
		  let windows = Zotero.getMainWindows();
		  for (let win of windows) {
			  if (win.ZoteroPane) return win.ZoteroPane
		  }
	  }
    async function focus_zotero_item(id) {
      let item = Zotero.Items.get(id)
      let zotero_pane = getZoteroPane();
      // Focus collection
      await zotero_pane.collectionsView.selectCollection(item._collections[0])
      // Focus item
      zotero_pane.selectItem(item._id)
    }

  focus_zotero_item('

	TMP_FILE="$(mktemp -t "tmp_XXX")"
	readonly TMP_FILE

	trap 'rm $TMP_FILE' EXIT

	IFS='' read -r -d '' cmd <<EOF
  cat "/tmp/result_null" |  fzf --multi --read0 --ansi --with-nth {5..} \
  --preview='$XDG_CONFIG_HOME/fzf/fzf_preview_media "\$(find {4}  -type f -name "*" ! -name ".*" 2>/dev/null)"'\
  --bind 'alt-u:execute-silent(xdg-open {3})' \
  --bind 'alt-q:execute-silent(dunstify {1})' \
  --bind 'alt-z:execute-silent(i3-msg '\''${ZOTERO_CONDITION} focus'\'' && /bin/nc 127.0.0.1 8080 < <(echo "${focus_zotero_item}{1})})();"))+abort' \
  --header 'Enter open document, A-u open link, A-z focus in zotero' \
  >| '${TMP_FILE}'
EOF

	eval_interactive_cmd --floating --geometry 'fullscreen toggle' "$cmd"

	[[ -s "$TMP_FILE" ]] || exit 1

	FILES_PATH="$(<"$TMP_FILE" cut -d $'\t' -f 4 | sed -n 'p;n')"

	while IFS= read -r FILE_PATH; do
		# Open document if directory exists; otherwise, open link
		if [[ -d "$FILE_PATH" ]]; then
			xdg-open "$(find "$FILE_PATH" -type f -name "*" ! -name ".*")" &
			disown
			i3-msg "workspace --no-auto-back-and-forth 8"
		else
			xdg-open "$(<"$TMP_FILE" cut -d $'\t' -f 3 | head -n 1)"
		fi
		fre --store_name "$FRE_NAME" --add "$(<"$TMP_FILE" cut -d $'\t' -f -1 | head -n 1)"
	done <<<"$FILES_PATH"
}

focus_zotero_entry_from_path() {
	path="$1"
	file_name="${path##*/}"

	i3-msg "$ZOTERO_CONDITION move workspace current, focus"
	SCRIPT='
(async function() {
    function getZoteroPane() {
		  let windows = Zotero.getMainWindows();
		  for (let win of windows) {
			  if (win.ZoteroPane) return win.ZoteroPane
		  }
	  }

    async function focus_zotero_item() {
      rows = await Zotero.DB.queryAsync("SELECT itemID, path FROM itemAttachments WHERE path LIKE ? ", [`storage:'"${file_name}"'`])
      id = rows[0].itemID;
      let attachmentItem = await Zotero.Items.get(id)
      entryItem = attachmentItem.parentItem
      let zotero_pane = getZoteroPane();
      // Focus collection
      await zotero_pane.collectionsView.selectCollection(entryItem._collections[0])
      // Focus item
      zotero_pane.selectItem(entryItem._id)
    }

  await focus_zotero_item();
})();
'
	nc 127.0.0.1 8080 < <(echo "$SCRIPT")
}

eval_script_return_value() {
	tmp="/tmp/search_zotero_${RANDOM}"

	SCRIPT='
  '"$1"'
  await Zotero.File.putContentsAsync("'"$tmp"'", result);
})();
'

	nc 127.0.0.1 8080 < <(echo "$SCRIPT")

	# Send script again, if Zotero doesn't respond
	# local TIMEOUT=2 START=$SECONDS FLAG="false"

	sleep 1
	until [[ -f "$tmp" ]]; do
		# [[ "$FLAG" != "true" ]] && ((SECONDS - START >= TIMEOUT)) && nc 127.0.0.1 8080 < <(echo "$SCRIPT") && FLAG="true"
		sleep 0.1
	done
	cat "$tmp"
	rm "$tmp"
}

main() {
	source "$HOME/.bashrc.d/functions.bash"

	# Open Zotero
	if ! is_window_exists "^Zotero$"; then
		nohup zotero >/dev/null 2>&1 &
		disown
		wait_window "^Zotero$"
		ZOTERO_CONDITION="$(window_get_condition "^Zotero$")"
		until nc -zv 127.0.0.1 8080 >/dev/null 2>&1; do
			sleep 0.1
		done
		sleep 2
		i3-msg "$ZOTERO_CONDITION move scratchpad"
	else
		ZOTERO_CONDITION="$(window_get_condition "^Zotero$")"
	fi

	case $1 in
		import)
			shift
			import_source "$@"
			;;
		get_metadata)
			shift
			get_metadata "$@"
			;;
		search)
			search_entries
			;;
		focus_entry)
			shift
			focus_zotero_entry_from_path "$@"
			;;
		*)
			dunstify "$1 utlity isn't supported" && exit 1
			;;
	esac
}

main "$@"
