#!/usr/bin/env bash
# Zotero utility:
# - Import to zotero from various sources to a collection
# - Get a paper's DOI or title
#
# Arguments:
#   zotero_utility [import|get_metadata] args
#
#   import:
#   --collection_name <collection_name>: Colletion name (optional)
#   or
#   --recent: Import to the collection that was imported before (optional)
#   <SOURCE>: URL or path to paper
#
#   get_metadata :
#   $1: [DOI|title]
#   $2; SOURCE: URL or path to paper
#
# Dependencies: zotero, netcat

get_collection_id_from_name() {
	local -r COLLECTION_NAME="$1"

	script='
  (async function () {
let collections = Zotero.Collections.getLoaded()
let collectionId = 0
for (let collection of collections) {
  if (collection.name == "'"$COLLECTION_NAME"'") {
    collectionId = collection.id;
    break;
  }
}

result=collectionId.toString()
'
	eval_script_return_value "$script"
}

pick_collection_id() {
	script='
  (async function () {
  let libraries = await Zotero.Libraries.getAll()

  let collections_str = ""

  function get_collections(collections, name) {

  for (let collection of collections) {
    if (collection.hasChildCollections()) {
      collections_str += collection.key + "\t" + name + " >> " + collection.name + "\n"
      get_collections(collection.getChildCollections(), name + " >> " + collection.name)
    } else {
    collections_str += collection.key + "\t" + name + " >> " + collection.name +"\n"
  }
}
return collections_str
}

let collections = await Zotero.Collections.getLoaded()

for (let library of libraries) {
  let collections = await Zotero.Collections.getByLibrary(library.id)
  collections_str += get_collections(collections, library.name)
}

result = collections_str
'

	result="$(eval_script_return_value "$script")"

	result="$(command cat <(fre --store_name "$FRE_NAME" --sorted | grep -Fx -f <(echo "$result")) <(echo "$result" | grep -Fvx -f <(fre --store_name "$FRE_NAME" --sorted)))"
	result="${result//>>/\\033[36m>>\\033[0m}"

	TMP_FILE="$(mktemp -t "tmp_XXX")"
	readonly TMP_FILE

	trap 'rm $TMP_FILE' RETURN

	IFS='' read -r -d '' cmd <<EOF
  printf "$result" |  fzf --ansi --with-nth '{2..}' --preview-window hidden >| '${TMP_FILE}'
EOF

	eval_interactive_cmd --floating "$cmd"

	[[ -s "$TMP_FILE" ]] || exit 0

	fre --store_name "$FRE_NAME" --add "$(cat "$TMP_FILE")"
	collection_key="$(<"$TMP_FILE" cut -d $'\t' -f 1)"

	script='
(async function () {
let libraryId = await Zotero.Libraries.getAll()[0].id

let collectionId = await Zotero.Collections.getByLibraryAndKey(libraryId, "'"$collection_key"'").id

result=collectionId.toString()
'
	eval_script_return_value "$script"
}

import_source() {
	local TMP_FILE_RECENT_COLLECTION_ID="$XDG_DATA_HOME/zotero_recent_collection_id"
	local COLLECTION_NAME RECENT SOURCE

	while :; do
		case $1 in
			--collection_name)
				COLLECTION_NAME="$2"
				shift
				;;
			--recent)
				RECENT="true"
				;;
			*)
				# Could be changed to remove em-dashes
				SOURCE="$1"
				break
				;;
		esac
		shift
	done

	declare -r FRE_NAME="zotero_collection"

	if [[ "$RECENT" == "true" ]]; then
		# Use most recent file
		source "$TMP_FILE_RECENT_COLLECTION_ID"
	elif [[ -n "$COLLECTION_NAME" ]]; then
		declare -r COLLECTION_ID="$(get_collection_id_from_name "$COLLECTION_NAME")"
	else # Pick interactively
		declare -r COLLECTION_ID="$(pick_collection_id)"
	fi
	# Don't track reading collection
	[[ -n "$COLLECTION_ID" && "$COLLECTION_NAME" != "To_Read" ]] && declare -p COLLECTION_ID >|"$TMP_FILE_RECENT_COLLECTION_ID"

	[[ -z "$COLLECTION_ID" ]] && exit 0

	if [[ -f "$SOURCE" ]]; then
		# Attach document

		# If filename contains an em-dash replace it, because JS doesn't like em-dashes
		if [[ "$(basename "$SOURCE")" =~ [—–] ]]; then
			OLD_SOURCE="$SOURCE"
			SOURCE="/tmp/$(basename "$OLD_SOURCE" | sed 's/[—–]/-/g')"
			cp -- "$OLD_SOURCE" "$SOURCE"
		fi

		# Convert to UTF-8 escape sequence (percent-encoding)
		SOURCE=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$SOURCE'))")
		import_script='
  (async function () {
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForCondition(conditionFn, timeoutMs, pollIntervalMs = 100) {
  const startTime = Date.now();

  while (true) {
    if (conditionFn()) { break; }

    if (Date.now() - startTime > timeoutMs) { break; }

    await sleep(pollIntervalMs);
  }
}
  function getZoteroPane() {
		var windows = Zotero.getMainWindows();
		for (let win of windows) {
			if (win.ZoteroPane) return win.ZoteroPane
		  }
	  }
    await getZoteroPane().collectionsView.selectCollection('"$COLLECTION_ID"')

    let path = decodeURIComponent("'$SOURCE'");
    items = await getZoteroPane().addAttachmentFromDialog(false, 0,[path]);
		await waitForCondition(() => items[0].parentID, 10000);
    result = await Zotero.BetterBibTeX.KeyManager.get(items[0].parentID).citationKey
  '

		eval_script_return_value "$import_script"
	elif curl --head "$SOURCE" >/dev/null; then

		HTML_PATH="$(mktemp -t "tmp_XXX")"
		readonly HTML_PATH

		trap 'rm -f $HTML_PATH' RETURN
		# Extract web page source code
		get_page_content "$SOURCE" "$HTML_PATH"

		# shellcheck disable=2016
		import_script='
  (async function () {
  var { library, collection, editable } = Zotero.Server.Connector.getSaveTarget();
  var libraryID = library.libraryID;
  let uri = "'"$SOURCE"'"

var cookieSandbox = uri
? new Zotero.CookieSandbox(null, uri, "", null)
: null;

var parser = new DOMParser();
var data = await Zotero.File.getContentsAsync("'"$HTML_PATH"'");

var doc = parser.parseFromString(`<html>${data}</html>`, "text/html");
doc = Zotero.HTTP.wrapDocument(doc, uri);

let translate = (this._translate = new Zotero.Translate.Web());
translate.setDocument(doc);
cookieSandbox && translate.setCookieSandbox(cookieSandbox);

translators = await translate.getTranslators();
if (translators.length == 0) {
    result = "Error: Entry not added"
} else {
translate.setTranslator(translators[0].translatorID);

let items = await translate.translate({
libraryID,
collections: ['"$COLLECTION_ID"'],
});

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function waitForCondition(conditionFn, timeoutMs, pollIntervalMs = 100) {
  const startTime = Date.now();

  while (true) {
    if (conditionFn()) { break; }

    if (Date.now() - startTime > timeoutMs) { break; }

    await sleep(pollIntervalMs);
  }
}

		await waitForCondition(() => items[0], 10000);
    result = await Zotero.BetterBibTeX.KeyManager.get(items[0].getID()).citationKey
}
'
		results="$(eval_script_return_value "$import_script")"
		if grep "Error:" <(echo "$results"); then
			exit 1
		else
			echo "$results"
			dunstify "Entry Added"
		fi
	else
		notify-send "Couldn't import to zotero: $SOURCE"
		exit 1
	fi
}

eval_script_return_value() {
	TMP_FILE2="/tmp/zotero_return_value"

	rm -f "$TMP_FILE2"
	trap 'rm -f $TMP_FILE2' RETURN

	local -r SCRIPT='
	'"$1"'
	await Zotero.File.putContentsAsync("'"$TMP_FILE2"'", result);
	})();
	'

	nc 127.0.0.1 8080 < <(echo "$SCRIPT")
	until [[ -f "$TMP_FILE2" ]]; do
		sleep 0.1
	done
	cat "$TMP_FILE2"
}

get_metadata() {

	if [[ "$1" != "DOI" && "$1" != "title" ]]; then
		dunstify "Error: first argument must be DOI or title."
		exit 1
	fi

	METADATA="$1"
	SOURCE="$2"

	if [[ -f "$SOURCE" ]]; then
		# Attach document

		# If filename contains an em-dash replace it, because JS doesn't like em-dashes
		if [[ "$(basename "$SOURCE")" =~ [—–] ]]; then
			OLD_SOURCE="$SOURCE"
			SOURCE="/tmp/$(basename "$OLD_SOURCE" | sed 's/[—–]/-/g')"
			cp -- "$OLD_SOURCE" "$SOURCE"
		fi

		SOURCE=$(python3 -c 'import urllib.parse; print(urllib.parse.quote("'"$SOURCE"'"))')
		SCRIPT='
(async function () {
    let path = decodeURIComponent("'$SOURCE'");

  try {
    // Create a linked file attachment (not stored in library)
    let attachment = await Zotero.Attachments.linkFromFile({
      file: path
    });

    // Use autoRecognizeItems to retrieve metadata
    // This is what "Retrieve Metadata for PDF" does internally
    await Zotero.RecognizeDocument.autoRecognizeItems([attachment]);

    // Get the DOI from the parent item that was created
    let metadata = null;
    if (attachment.parentID) {
      let parentItem = await Zotero.Items.getAsync(attachment.parentID);
      if (parentItem) {
        metadata = parentItem.getField("'"$METADATA"'");
        // Clean up - delete both parent and attachment
        await parentItem.eraseTx();
      }
    }
     result = metadata

    // Clean up the attachment if no parent was created
    if (!attachment.parentID) {
      await attachment.eraseTx();
    }

  } catch (error) {
    return "Error: " + error.message;
  }
  '
	elif curl --head "$SOURCE" >/dev/null; then

		HTML_PATH="$(mktemp -t "tmp_XXX.html")"
		readonly HTML_PATH

		trap 'rm -f $HTML_PATH' RETURN
		get_page_content "$SOURCE" "$HTML_PATH"

		# shellcheck disable=2016
		SCRIPT='
  (async function () {
    let url = "'"$SOURCE"'"
    var cookieSandbox = url
      ? new Zotero.CookieSandbox(null, url, "", null)
      : null;

    var parser = new DOMParser();
    var data = await Zotero.File.getContentsAsync("'"$HTML_PATH"'");
    var doc = parser.parseFromString(`<html>${data}</html>`, "text/html");
    doc = Zotero.HTTP.wrapDocument(doc, url);

    let translate = new Zotero.Translate.Web();
    translate.setDocument(doc);
    cookieSandbox && translate.setCookieSandbox(cookieSandbox);

    let translators = await translate.getTranslators();

    if (translators.length == 0) {
      result = "Error: No translators found";
    } else {
      translate.setTranslator(translators[0].translatorID);

      // Set handler to capture items WITHOUT saving them
      translate.setHandler("itemDone", function(obj, item) {
        if (item.'"$METADATA"') {
          result = item.'"$METADATA"';
        } else {
          result = "No '"$METADATA"' found";
        }
      });

      // Translate without saving to library
      await translate.translate({
        libraryID: false  // Dont save to any library
      });
    }
  '
	fi
	eval_script_return_value "$SCRIPT"
}

main() {
	if ! pgrep zotero >/dev/null; then
		nohup zotero >/dev/null 2>&1 &
		disown
		until nc -zv 127.0.0.1 8080 >/dev/null 2>&1; do
			sleep 0.1
		done
		i3-msg '[class="Zotero"] move scratchpad' >/dev/null
	fi

	case $1 in
		import)
			shift
			import_source "$@"
			;;
		get_metadata)
			shift
			get_metadata "$@"
			;;
		*)
			dunstify "$1 utlity isn't supported" && exit 1
			;;
	esac
}

main "$@"
