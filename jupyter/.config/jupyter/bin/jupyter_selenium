#!/usr/bin/env -S uv run --script
#
# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "flask",
#     "selenium",
#     "webdriver-manager",
#     "watchdog",
#     "jupyter-server"
# ]
# ///

import os
import signal
import subprocess
import threading
import time

from flask import Flask, request
from pathlib import Path
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from watchdog.events import FileSystemEventHandler
from selenium.common.exceptions import WebDriverException
from watchdog.observers import Observer
from webdriver_manager.chrome import ChromeDriverManager

signal_event = threading.Event()

is_signal_recieved_from_vim = False
jupyter_process = None


def wait_for_signal(timeout=5):
    global is_signal_recieved_from_vim
    if not is_signal_recieved_from_vim:
        return
    print("Waiting for signal...")
    received = signal_event.wait(timeout=timeout)
    if received:
        print("Signal received!")
        signal_event.clear()  # reset for next wait
    else:
        print("Timeout, no signal received.")
    is_signal_recieved_from_vim = False
    return received


def set_vim_signal_to_false():
    global is_signal_recieved_from_vim
    is_signal_recieved_from_vim = False


class NotebookExecutor:
    def __init__(self):
        pass
        # Other potential methods to use
        # notebook:restart-clear-output
        # notebook:restart-and-run-to-selected

    def run_cells(self, cell_indices):
        driver.execute_script(
            f"""
            const panel = window.jupyterapp.shell.currentWidget;
            const nb = panel.content;
            const indexes = {str(cell_indices)};

            nb.scrollToItem({cell_indices[0]});
            for (let i = 0; i < indexes.length; i++) {{
                nb.activeCellIndex = indexes[i];
                nb.select(nb.widgets[indexes[i]]);  // selects first cell and clears previous selection
            }}

            nb.scrollToItem({cell_indices[-1]});
            window.jupyterapp.commands.execute('notebook:run-cell');

            """
        )

        driver.find_element(By.CSS_SELECTOR, ".jp-Notebook.jp-WindowedPanel").send_keys(
            Keys.CONTROL + "s"
        )
        return {"status": f"Executed cell {cell_indices}"}

    def run_all_cells(self):
        driver.execute_script(
            """
            window.jupyterapp.commands.execute('notebook:run-all-cells');
            """
        )

        driver.find_element(By.CSS_SELECTOR, ".jp-Notebook.jp-WindowedPanel").send_keys(
            Keys.CONTROL + "s"
        )
        return {"status": "Executed all cell"}

    def goto_cell(self, cell_index):
        driver.execute_script(
            f"""
            const panel = window.jupyterapp.shell.currentWidget;
            const nb = panel.content;

            nb.scrollToItem({cell_index});
            nb.activeCellIndex = {cell_index};
            """
        )
        return {"status": "Going to next cell"}

    def restart_kernel(self):
        driver.execute_script(
            """
            window.jupyterapp.commands.execute('notebook:restart-kernel');
            """
        )
        return {"status": "Restarting Kernel"}

    def shutdown_kernel(self):
        driver.execute_script(
            """
            window.jupyterapp.commands.execute('notebook:shutdown-kernel');
            """
        )
        return {"status": "Restarting Kernel"}


# Flask API
app = Flask(__name__)


# Timeout script if flask hasn't been used for some time
last_used = time.time()


@app.before_request
def update_last_used():
    global last_used
    last_used = time.time()


def watchdog(timeout=3600):
    global last_used
    while True:
        time.sleep(60)  # check every minute
        if time.time() - last_used > timeout:
            print("Idle for too long, shutting down.")
            shutdown()


tabs = {}


def goto_page(file_path):
    notebook_url = get_notebook_link_from_file(file_path)

    # Don't focus browser when opening and moving through tabs
    subprocess.Popen(
        [
            os.path.expandvars(
                "$XDG_CONFIG_HOME/i3/set_i3_focus_on_window_activation_configuration"
            ),
            "none",
            "3",
        ],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    if driver.current_url is None:
        driver.switch_to.window(driver.window_handles[-1])
    if notebook_url == driver.current_url:
        return
    # if tab already exists, switch to it
    if notebook_url in tabs:
        handle = tabs[notebook_url]
        # If tab got closed, update tabs and open page
        if handle not in driver.window_handles:
            for key, val in list(tabs.items()):
                if val == handle:
                    del tabs[key]
                    break
            goto_page(file_path)
            return
        driver.switch_to.window(handle)  # switch to the tab
    else:
        # Else create new tab and add it in tabs
        driver.switch_to.new_window("tab")
        driver.get(notebook_url)

        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located(
                (By.CSS_SELECTOR, ".jp-Notebook.jp-WindowedPanel")
            )
        )

        body = driver.find_element(By.TAG_NAME, "body")
        body.send_keys(Keys.TAB)  # or any key, will focus body first
        tabs[notebook_url] = driver.current_window_handle


@app.route("/run_all_cells", methods=["GET"])
def run_all_cells():
    global is_signal_recieved_from_vim
    is_signal_recieved_from_vim = True
    threading.Timer(3, set_vim_signal_to_false).start()
    data = request.get_json(force=True)
    file_path = data.get("file_path")
    goto_page(file_path)
    executor.run_all_cells()
    return ""


@app.route("/send_save_signal", methods=["GET"])
def send_save_signal():
    global is_signal_recieved_from_vim
    is_signal_recieved_from_vim = True
    threading.Timer(3, set_vim_signal_to_false).start()

    return ""


@app.route("/restart_kernel", methods=["GET"])
def resetart_kernel():
    data = request.get_json(force=True)
    file_path = data.get("file_path")
    goto_page(file_path)
    executor.restart_kernel()
    return ""


@app.route("/goto_cell", methods=["GET"])
def goto_cell():
    data = request.get_json(force=True)
    idx = data.get("index")
    file_path = data.get("file_path")

    goto_page(file_path)
    executor.goto_cell(idx)
    return ""


@app.route("/run_cells", methods=["GET"])
def run_cells():
    threading.Timer(3, set_vim_signal_to_false).start()
    signal_event.clear()  # reset for next wait
    wait_for_signal(timeout=2)
    data = request.get_json(force=True)
    idx = data.get("index")
    file_path = data.get("file_path")

    goto_page(file_path)
    global is_signal_recieved_from_vim
    is_signal_recieved_from_vim = True
    executor.run_cells(idx)
    return ""


@app.route("/shutdown", methods=["POST"])
def shutdown():
    executor.shutdown_kernel()
    driver.quit()
    jupyter_process.terminate()
    os.kill(os.getpid(), signal.SIGINT)
    return "Shutting down", 200


@app.route("/run", methods=["POST"])
def run():
    global driver, tabs
    data = request.get_json(force=True)
    # If driver exited, run another one
    try:
        driver.title
        return ""
    except WebDriverException:
        file_path = data.get("file_path")
        driver = webdriver.Chrome(
            service=Service(ChromeDriverManager().install()), options=chrome_options
        )

        tabs = {}
        notebook_url = get_notebook_link_from_file(file_path)

        driver.get(notebook_url)
        tabs[notebook_url] = driver.current_window_handle
        return ""


class PySyncHandler(FileSystemEventHandler):
    def __init__(self):
        self.notebook_changed = False
        self.py_changed = False
        self._timers = {}  # keep active timers by attribute name

    def transform_py_to_ipynb(self, py_path, notebook_path):
        subprocess.run(
            [
                "jupytext",
                "--to",
                "ipynb",
                py_path,
                "--output",
                notebook_path,
                "--update",
            ]
        )
        driver.find_element(By.CSS_SELECTOR, ".jp-Notebook").send_keys(
            Keys.CONTROL + Keys.SHIFT + "q"
        )

        # If notebook is edited, a reload button is given, press it to override the notebook
        buttons = driver.find_elements(
            By.CSS_SELECTOR, ".jp-Dialog-button.jp-mod-accept"
        )

        if len(buttons) > 0:
            buttons[0].click()

        # driver.find_element(By.CSS_SELECTOR, ".jp-Notebook").send_keys(
        #     Keys.CONTROL + "s"
        # )
        signal_event.set()
        print("Notebook modified:", notebook_path)

    def transform_ipynb_to_py(self, py_path, notebook_path):
        subprocess.run(
            [
                "jupytext",
                "--to",
                "py",
                notebook_path,
                "--output",
                py_path,
            ]
        )
        print("Python file modified:", py_path)

    def schedule_var(self, name, value, delay):
        # cancel previous timer for this var if exists
        if name in self._timers:
            self._timers[name].cancel()

        t = threading.Timer(delay, self.set_var, args=(name, value))
        t.start()
        self._timers[name] = t

    def set_var(self, name, value):
        setattr(self, name, value)
        # timer finished, remove from dict
        self._timers.pop(name, None)

    def on_closed(self, event):
        global is_signal_recieved_from_vim
        if event.is_directory:
            return

        if event.src_path.endswith(".py"):
            if self.notebook_changed:
                self.schedule_var("notebook_changed", False, 3)
                return ""
            self.py_changed = True
            py_path = event.src_path
            notebook_path = f"{event.src_path[:-3]}.ipynb"
            # If notebook version doesn't exist, don't run jupytext
            if not os.path.exists(notebook_path):
                return ""
            goto_page(os.path.abspath(py_path))
            self.transform_py_to_ipynb(py_path, notebook_path)

        if event.src_path.endswith(".ipynb"):
            if self.py_changed:
                self.schedule_var("py_changed", False, 3)
                return ""
            if is_signal_recieved_from_vim:
                return ""
            self.notebook_changed = True
            notebook_path = event.src_path
            py_path = f"{event.src_path[:-6]}.py"

            if os.path.exists(py_path):
                self.transform_ipynb_to_py(py_path, notebook_path)


def get_running_jupyter_in_cwd(cwd):
    from jupyter_server.serverapp import list_running_servers

    project_dir = find_pyproject_root(cwd)
    for server in list_running_servers():
        if server["root_dir"] == project_dir:
            return server
    return None


def start_jupyter_server(cwd):
    global jupyter_process
    project_dir = find_pyproject_root(cwd)
    jupyter_process = subprocess.Popen(
        [
            "python",
            "-m",
            "jupyter",
            "notebook",
            "--notebook-dir",
            project_dir,
            "--NotebookApp.answer_yes",
            "True",
            "--expose-app-in-browser",
            "--no-browser",
        ],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )


def get_notebook_link_from_file(file_path):
    # Get file path from jupyter server root directory
    jupyter_server = get_running_jupyter_in_cwd(cwd)
    file_rel_path = file_path[len(jupyter_server["root_dir"]) + 1 :]
    # Remove .py extension
    file_rel_path_without_ext = file_rel_path[:-3]

    return f"http://localhost:{jupyter_server['port']}/notebooks/{file_rel_path_without_ext}.ipynb"


def find_pyproject_root(start_path=None):
    """Find directory containing pyproject.toml"""
    path = Path(start_path or Path.cwd()).resolve()

    for directory in [path, *path.parents]:
        if (directory / "pyproject.toml").exists():
            return str(directory)

    return None


if __name__ == "__main__":
    import os
    import sys

    cwd = os.getcwd()
    if len(sys.argv) < 3:
        exit()
    file_path = sys.argv[1]
    flask_port = int(sys.argv[2])

    jupyter_server = get_running_jupyter_in_cwd(cwd)
    if jupyter_server is None:
        start_jupyter_server(cwd)
        jupyter_server = get_running_jupyter_in_cwd(cwd)

    # Wait until server is running
    while not jupyter_server:
        time.sleep(1)
        jupyter_server = get_running_jupyter_in_cwd(cwd)

    chrome_options = Options()
    chrome_options.add_argument("--start-maximized")
    driver = webdriver.Chrome(
        service=Service(ChromeDriverManager().install()), options=chrome_options
    )

    notebook_url = get_notebook_link_from_file(file_path)

    driver.get(notebook_url)
    tabs[notebook_url] = driver.current_window_handle

    executor = NotebookExecutor()

    event_handler = PySyncHandler()
    observer = Observer()
    observer.schedule(event_handler, ".", recursive=True)
    observer.start()

    threading.Thread(target=watchdog, daemon=True).start()
    app.run(port=flask_port)

# vim:filetype=python
